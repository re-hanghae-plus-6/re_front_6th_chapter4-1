# 웹 렌더링 방식 비교: SSG vs SSR vs CSR

## 개요
웹 애플리케이션을 개발할 때 선택할 수 있는 주요 렌더링 방식인 정적 사이트 생성(SSG), 서버 사이드 렌더링(SSR), 클라이언트 사이드 렌더링(CSR)에 대해 비교 분석합니다.

## 1. CSR (Client-Side Rendering) - 클라이언트 사이드 렌더링

### 개념
- 브라우저에서 JavaScript를 실행하여 DOM을 동적으로 생성하는 방식
- 서버는 최소한의 HTML과 JavaScript 번들을 전송
- 모든 렌더링 로직이 클라이언트에서 실행

### 동작 과정
1. 서버에서 기본 HTML 템플릿과 JavaScript 번들 전송
2. 브라우저에서 JavaScript 다운로드 및 실행
3. API 호출을 통해 데이터 가져오기
4. Virtual DOM을 통해 실제 DOM 렌더링

### 장점
- **빠른 페이지 전환**: 초기 로드 후 SPA 방식으로 빠른 네비게이션
- **서버 부하 감소**: 렌더링 작업을 클라이언트로 분산
- **풍부한 상호작용**: 동적인 UI와 사용자 경험 제공
- **개발 생산성**: 컴포넌트 기반 개발로 재사용성 높음

### 단점
- **초기 로딩 시간**: JavaScript 번들 다운로드로 인한 지연
- **SEO 문제**: 검색 엔진 크롤러가 동적 콘텐츠 인덱싱 어려움
- **성능 이슈**: 저사양 디바이스에서 JavaScript 실행 부담
- **빈 화면 문제**: JavaScript 로드 전까지 빈 페이지 표시

### 적합한 사용 사례
- 관리자 대시보드, 복잡한 웹 애플리케이션
- 실시간 데이터 업데이트가 필요한 서비스
- 사용자 상호작용이 많은 애플리케이션

## 2. SSR (Server-Side Rendering) - 서버 사이드 렌더링

### 개념
- 서버에서 HTML을 완전히 렌더링한 후 클라이언트로 전송하는 방식
- 각 요청마다 서버에서 동적으로 HTML 생성
- 클라이언트에서는 하이드레이션 과정을 통해 상호작용 가능

### 동작 과정
1. 클라이언트에서 페이지 요청
2. 서버에서 데이터 가져오기 및 HTML 렌더링
3. 완성된 HTML을 클라이언트로 전송
4. 클라이언트에서 JavaScript 로드 및 하이드레이션

### 장점
- **빠른 초기 렌더링**: 완성된 HTML 즉시 표시
- **우수한 SEO**: 서버에서 완성된 HTML 제공으로 검색엔진 최적화
- **향상된 성능**: 저사양 디바이스에서도 빠른 초기 로딩
- **소셜 미디어 최적화**: 메타 태그 정보를 서버에서 제공

### 단점
- **서버 부하**: 모든 요청마다 서버에서 렌더링 수행
- **복잡한 캐싱**: 동적 콘텐츠 캐싱 전략 수립 어려움
- **TTFB 지연**: 서버 렌더링 시간만큼 첫 바이트 도달 시간 증가
- **개발 복잡성**: 서버와 클라이언트 코드 동기화 필요

### 적합한 사용 사례
- 블로그, 뉴스 사이트, 전자상거래 사이트
- SEO가 중요한 마케팅 페이지
- 개인화된 콘텐츠를 제공하는 서비스

## 3. SSG (Static Site Generation) - 정적 사이트 생성

### 개념
- 빌드 타임에 미리 HTML 파일을 생성하는 방식
- 서버는 정적 파일만 제공하면 되므로 매우 빠름
- 동적 데이터는 빌드 시점의 데이터로 고정

### 동작 과정
1. 빌드 타임에 모든 페이지의 HTML 사전 생성
2. CDN 또는 정적 파일 서버에 배포
3. 클라이언트 요청 시 사전 생성된 HTML 즉시 전송
4. 필요한 경우 JavaScript로 하이드레이션

### 장점
- **최고의 성능**: 정적 파일 서빙으로 매우 빠른 로딩
- **완벽한 SEO**: 사전 생성된 HTML로 검색엔진 최적화
- **높은 보안성**: 서버 사이드 로직 없어 보안 위험 최소화
- **경제적**: CDN 활용으로 저렴한 호스팅 비용

### 단점
- **빌드 시간 증가**: 페이지 수에 비례하여 빌드 시간 길어짐
- **동적 콘텐츠 제한**: 실시간 데이터 반영 어려움
- **업데이트 복잡성**: 콘텐츠 변경 시 전체 재빌드 필요
- **확장성 한계**: 대량의 동적 페이지 처리 어려움

### 적합한 사용 사례
- 문서 사이트, 포트폴리오, 기업 홈페이지
- 콘텐츠 변경이 적은 마케팅 사이트
- JAMstack 아키텍처 기반 프로젝트

## 비교표

| 특성 | CSR | SSR | SSG |
|------|-----|-----|-----|
| **초기 로딩 속도** | 느림 | 빠름 | 매우 빠름 |
| **SEO** | 어려움 | 우수 | 완벽 |
| **서버 부하** | 낮음 | 높음 | 매우 낮음 |
| **개발 복잡성** | 보통 | 높음 | 낮음 |
| **동적 콘텐츠** | 우수 | 우수 | 제한적 |
| **캐싱** | 쉬움 | 복잡 | 매우 쉬움 |
| **호스팅 비용** | 보통 | 높음 | 낮음 |
| **실시간 업데이트** | 우수 | 가능 | 어려움 |
| **보안** | 보통 | 보통 | 높음 |
| **확장성** | 높음 | 보통 | 보통 |

## 성능 메트릭 비교

### Core Web Vitals 기준

| 메트릭 | CSR | SSR | SSG |
|--------|-----|-----|-----|
| **FCP (First Contentful Paint)** | 느림 | 빠름 | 매우 빠름 |
| **LCP (Largest Contentful Paint)** | 느림 | 빠름 | 매우 빠름 |
| **TTI (Time to Interactive)** | 느림 | 보통 | 빠름 |
| **CLS (Cumulative Layout Shift)** | 위험 | 낮음 | 매우 낮음 |

## 하이브리드 접근법

### ISR (Incremental Static Regeneration)
- Next.js에서 제공하는 SSG + SSR 하이브리드 방식
- 정적 생성의 장점을 유지하면서 동적 업데이트 가능
- 백그라운드에서 페이지 재생성으로 성능과 신선도 균형

### Islands Architecture
- 정적 HTML 위에 필요한 부분만 하이드레이션
- Astro, Fresh 등에서 사용하는 방식
- 성능 최적화와 상호작용성 양립

## 선택 가이드

### CSR을 선택해야 하는 경우
- 복잡한 사용자 상호작용이 필요한 웹 애플리케이션
- 실시간 데이터 업데이트가 중요한 서비스
- SEO가 중요하지 않은 내부 도구나 대시보드

### SSR을 선택해야 하는 경우
- SEO가 중요한 콘텐츠 사이트
- 개인화된 콘텐츠를 제공하는 서비스
- 빠른 초기 로딩과 동적 콘텐츠 모두 필요한 경우

### SSG를 선택해야 하는 경우
- 콘텐츠 변경이 적은 정적 사이트
- 최고의 성능과 SEO가 필요한 경우
- 보안이 중요하고 서버 부하를 최소화하려는 경우

## 결론

각 렌더링 방식은 고유한 장단점을 가지고 있으며, 프로젝트의 요구사항에 따라 적절한 방식을 선택하는 것이 중요합니다. 최근에는 하이브리드 접근법을 통해 각 방식의 장점을 결합하여 사용하는 것이 트렌드가 되고 있습니다.

현대의 프레임워크들(Next.js, Nuxt.js, SvelteKit 등)은 이러한 다양한 렌더링 방식을 하나의 프레임워크 내에서 유연하게 사용할 수 있도록 지원하고 있어, 페이지별로 최적의 렌더링 전략을 선택할 수 있습니다. 