# SSG(Static Site Generation) 구현 Q&A

## Q1: 다음은 ssg 설정을 위해서 구현한 코드야. 현재 staged된 코드를 보고 왜 ssg를 위해서 해당 코드들이 필요한지 알려줘.

### A1: SSG는 빌드 시점에 모든 가능한 페이지를 미리 생성하여 런타임 성능을 극대화하고, SEO 최적화와 CDN 활용을 위해 구현되었습니다.

## SSG 구현 핵심 구성 요소 분석

### 1. MSW 서버와 Vite 설정
```javascript
import { mswServer } from "./src/mocks/node.js";
import { createServer } from "vite";

mswServer.listen({
  onUnhandledRequest: "bypass",
});

const vite = await createServer({
  server: { middlewareMode: true },
  appType: "custom",
});
```

**왜 필요한가:**
- **MSW**: 빌드 시점에 실제 API 없이도 목 데이터로 SSR 실행 가능
- **Vite**: TypeScript/ES6 모듈을 실행 시점에 변환하여 `main-server.js` 로드 가능
- **빌드 시점 렌더링**: 실제 서버 환경 없이도 페이지 생성 가능

### 2. 서버 렌더링 모듈 로드
```javascript
const { render } = await vite.ssrLoadModule("./src/main-server.js");
```

**역할:**
- 기존 SSR 코드를 그대로 재사용
- 각 경로별로 동적 데이터와 HTML 생성
- 런타임이 아닌 빌드 타임에 실행

### 3. HTML 템플릿 준비
```javascript
const template = fs.readFileSync(joinDist("/index.html"), "utf-8");
```

**필요성:**
- 기본 HTML 구조 (head, body 등) 제공
- 플레이스홀더 (`<!--app-html-->`, `<!--app-head-->`) 포함
- 각 페이지가 이 템플릿을 기반으로 생성됨

### 4. 동적 페이지별 HTML 생성 함수
```javascript
async function generateStaticSite(pathname, ssg) {
  const fullPathname = pathname.endsWith(".html") ? 
    joinDist(pathname) : 
    joinDist(pathname, "/index.html");
  
  const rendered = await render(pathname, {}, ssg);
  
  const html = template
    .replace(`<!--app-head-->`, rendered.head ?? "")
    .replace(`<!--app-html-->`, rendered.html ?? "")
    .replace(
      `<!-- app-data -->`,
      `<script>window.__INITIAL_DATA__ = ${JSON.stringify(rendered.__INITIAL_DATA__)};</script>`,
    );
  
  if (!fs.existsSync(parsedPath.dir)) {
    fs.mkdirSync(parsedPath.dir, { recursive: true });
  }
  
  fs.writeFileSync(fullPathname, html);
}
```

**핵심 역할:**

#### A. 경로별 파일 생성
```javascript
// 경로 변환 예시
"/" → "dist/vanilla/index.html"
"/product/123/" → "dist/vanilla/product/123/index.html"
"/404.html" → "dist/vanilla/404.html"
```

#### B. 템플릿 조합
```javascript
// SEO를 위한 메타데이터 주입
.replace(`<!--app-head-->`, rendered.head)

// 서버 렌더링된 HTML 주입  
.replace(`<!--app-html-->`, rendered.html)

// 클라이언트 하이드레이션용 데이터 주입
.replace(`<!-- app-data -->`, `<script>window.__INITIAL_DATA__ = ...`)
```

#### C. 디렉토리 구조 생성
```javascript
// /product/123/index.html을 위해 product/123/ 폴더 자동 생성
if (!fs.existsSync(parsedPath.dir)) {
  fs.mkdirSync(parsedPath.dir, { recursive: true });
}
```

### 5. 정적 데이터 소스
```javascript
import items from "./src/mocks/items.json" with { type: "json" };

const getProducts = ({ category2 } = {}) => {
  const filterByCategory = (data) => {
    if (category2) {
      return data.filter((v) => v.category2 === category2);
    }
    return data;
  };

  const products = filterByCategory(items);
  return { 
    products: products.sort((a, b) => +a.lprice - +b.lprice).slice(0, 20), 
    totalCount: products.length 
  };
};
```

**필요성:**
- **빌드 시점 데이터**: 런타임 API 호출 없이 정적 데이터 사용
- **동적 필터링**: 카테고리별 상품 필터링 지원
- **정렬과 페이징**: 가격 순 정렬 및 20개 제한

### 6. 사전 정의된 경로 생성
```javascript
// 404 페이지 생성
await generateStaticSite("/404.html");

// 홈페이지 생성  
await generateStaticSite("/");

// 모든 상품 상세페이지 생성
const { products } = getProducts();
for (const { productId } of products) {
  await generateStaticSite(`/product/${productId}/`);
}
```

**전략:**
- **필수 페이지**: 404, 홈페이지는 항상 생성
- **동적 경로**: 모든 상품에 대해 개별 HTML 미리 생성
- **확장 가능**: 카테고리 페이지, 검색 결과 등 추가 생성 가능

## SSG의 핵심 이점

### 1. 런타임 성능 극대화
```javascript
// SSG: 정적 파일 서빙
GET /product/123/ 
→ 즉시 HTML 파일 반환 (1-5ms)
→ 서버 연산 없음

// vs SSR: 매번 서버 렌더링
GET /product/123/ 
→ DB 조회 (50-200ms)
→ 데이터 처리 (10-50ms)  
→ HTML 렌더링 (20-100ms)
→ 총 80-350ms
```

### 2. CDN 최적화
```javascript
// 모든 파일이 정적이므로 CDN 캐싱 최적화
Cache-Control: public, max-age=31536000  // 1년 캐싱
ETag: "abc123"  // 효율적인 캐시 검증

// 전 세계 어디서든 빠른 접근
서울 사용자 → 서울 CDN → 즉시 응답
뉴욕 사용자 → 뉴욕 CDN → 즉시 응답
```

### 3. 서버 인프라 비용 절감
```javascript
// SSG: 정적 호스팅만 필요
- AWS S3 + CloudFront
- Vercel Static
- Netlify Static
- 비용: 월 $1-10

// vs SSR: 서버 인스턴스 필요
- AWS EC2 + Load Balancer
- 비용: 월 $50-200+
```

### 4. SEO 최적화
```html
<!-- 각 페이지마다 고유한 메타데이터 -->
<title>아이폰 14 Pro - 최저가 쇼핑몰</title>
<meta name="description" content="아이폰 14 Pro 최저가 비교, 리뷰, 스펙 정보">
<meta property="og:title" content="아이폰 14 Pro">
<meta property="og:image" content="/images/iphone14pro.jpg">

<!-- 검색엔진이 완성된 HTML을 즉시 인덱싱 가능 -->
```

## 생성된 파일 구조 예시

### 디렉토리 구조
```
dist/vanilla/
├── index.html                 # 홈페이지
├── 404.html                   # 404 페이지
└── product/
    ├── 1001/
    │   └── index.html         # 상품 ID 1001 페이지
    ├── 1002/
    │   └── index.html         # 상품 ID 1002 페이지
    └── ...                    # 모든 상품별 폴더
```

### 각 HTML 파일 내용
```html
<!-- product/1001/index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>아이폰 14 Pro - 쇼핑몰</title>
  <meta name="description" content="...">
</head>
<body>
  <!-- 서버에서 렌더링된 완성된 HTML -->
  <div class="product-detail">
    <h1>아이폰 14 Pro</h1>
    <p>1,350,000원</p>
    <!-- 완성된 상품 정보 -->
  </div>
  
  <!-- 하이드레이션용 데이터 -->
  <script>
    window.__INITIAL_DATA__ = {
      currentProduct: { productId: 1001, title: "아이폰 14 Pro", ... },
      relatedProducts: [...]
    };
  </script>
  <script src="/assets/main.js"></script>
</body>
</html>
```

## 다른 렌더링 방식과의 비교

### SSG (Static Site Generation)
```javascript
// 빌드 시: 모든 HTML 미리 생성
npm run build → 500개 상품 × 각각 HTML 파일 생성

// 런타임: 정적 파일 서빙만
GET /product/123/ → 파일 시스템에서 HTML 반환

// 장점: 매우 빠름, CDN 친화적, 서버 비용 절감
// 단점: 동적 콘텐츠 제한, 빌드 시간 증가
```

### SSR (Server-Side Rendering)  
```javascript
// 빌드 시: 서버 코드만 준비
npm run build → 서버 번들 생성

// 런타임: 요청마다 HTML 생성
GET /product/123/ → DB 조회 → HTML 렌더링 → 반환

// 장점: 완전 동적 콘텐츠, 실시간 데이터
// 단점: 서버 부하, 응답 시간, 인프라 비용
```

### SPA (Single Page Application)
```javascript
// 빌드 시: 클라이언트 JS 번들만 생성
npm run build → main.js, style.css 생성

// 런타임: 브라우저에서 모든 렌더링
GET / → 빈 HTML + JS → 브라우저에서 API 호출 → 렌더링

// 장점: 높은 상호작용성, 부드러운 전환
// 단점: 초기 로딩 느림, SEO 문제, 브라우저 부담
```

## 하이브리드 접근법 가능성

### ISR (Incremental Static Regeneration)
```javascript
// Next.js 스타일 개선 가능성
export const getStaticProps = {
  revalidate: 3600  // 1시간마다 재생성
}

// 런타임에 필요시 페이지 재생성 가능
```

### 부분적 동적 콘텐츠
```javascript
// 정적 페이지 + 클라이언트 사이드 동적 요소
// 예: 정적 상품 정보 + 동적 리뷰 섹션
<div class="product-static">정적 콘텐츠</div>
<div class="product-dynamic" data-load="reviews">동적 로딩</div>
```

## 성능 벤치마크 (예상)

### 페이지 로드 시간
```javascript
// SSG
TTFB (Time to First Byte): 10-50ms
FCP (First Contentful Paint): 200-500ms
TTI (Time to Interactive): 500-1000ms

// SSR  
TTFB: 100-500ms
FCP: 500-1200ms
TTI: 800-1500ms

// SPA
TTFB: 10-50ms
FCP: 1000-3000ms (JS 로딩 + API 호출)
TTI: 1500-4000ms
```

### 서버 리소스
```javascript
// SSG
CPU 사용률: 0% (정적 서빙)
메모리 사용률: 최소
동시 사용자 처리: 무제한 (CDN 기준)

// SSR
CPU 사용률: 30-80% (렌더링 부하)
메모리 사용률: 중간-높음
동시 사용자 처리: 서버 스펙 의존
```

## 배포 전략

### 1. 빌드 자동화
```javascript
// package.json
{
  "scripts": {
    "build": "vite build && node static-site-generate.js",
    "deploy": "npm run build && aws s3 sync dist/ s3://my-bucket"
  }
}
```

### 2. CDN 설정
```javascript
// CloudFront 설정 예시
{
  "CachePolicyId": "static-content",
  "TTL": 31536000,  // 1년
  "Compress": true,
  "ViewerProtocolPolicy": "redirect-to-https"
}
```

### 3. 업데이트 전략
```javascript
// 상품 정보 변경 시
1. 데이터 업데이트 (items.json)
2. 전체 재빌드 (npm run build)  
3. CDN 캐시 무효화 (aws cloudfront create-invalidation)
4. 새 버전 배포
```

## 한계점과 해결 방안

### 한계점
1. **동적 콘텐츠 제한**: 실시간 데이터 반영 어려움
2. **빌드 시간 증가**: 페이지 수 증가에 따른 빌드 시간 상승
3. **데이터 신선도**: 빌드 시점 데이터로 고정

### 해결 방안
1. **하이브리드 접근**: 정적 콘텐츠 + 클라이언트 동적 로딩
2. **증분 빌드**: 변경된 페이지만 재생성
3. **예약 빌드**: 정기적 자동 빌드로 데이터 신선도 유지

## 결론

이 SSG 구현의 핵심 가치:

### 1. 성능 최적화
- **즉시 로딩**: 정적 파일 서빙으로 최소 지연시간
- **CDN 활용**: 전 세계 빠른 콘텐츠 배포
- **서버 부하 제거**: 렌더링 연산 없음

### 2. 경제성
- **인프라 비용 절감**: 정적 호스팅 비용만
- **확장성**: 트래픽 증가에도 추가 비용 없음
- **유지보수**: 단순한 아키텍처

### 3. SEO와 접근성
- **완성된 HTML**: 검색엔진 최적화
- **빠른 초기 렌더링**: 사용자 경험 향상
- **높은 가용성**: 단순한 구조로 장애 위험 최소

### 4. 개발 효율성
- **기존 코드 재사용**: SSR 코드 그대로 활용
- **표준 도구**: Vite, Node.js 표준 API 사용
- **확장 가능**: 새로운 페이지 타입 쉽게 추가

**결과: 전자상거래/블로그 같은 콘텐츠 중심 사이트에 최적화된 고성능 배포 전략**이 완성되었습니다.