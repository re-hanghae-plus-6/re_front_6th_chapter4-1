# SSR 환경에서 라우터 분리 Q&A

## Q1: 현재 staged된 코드는 serverRouter와 clientRouter를 분리한건데, 왜 이렇게 해야하는거야?

### A1: SSR에서 라우터를 분리하는 이유는 **서버와 클라이언트 환경의 차이점** 때문입니다.

### 환경별 API 차이
```javascript
// 문제: 서버에는 window 객체가 없음
window.location.pathname      // ❌ 서버에서 에러
window.history.pushState()    // ❌ 서버에서 에러
window.addEventListener()     // ❌ 서버에서 에러
```

### 서버에서 필요한 기능
- **URL 파싱**: 서버는 `req.url`에서 경로 정보를 받아야 함
- **정적 라우팅**: 서버는 히스토리 관리가 불필요
- **초기 매칭만**: 서버는 한 번만 라우트 매칭하고 끝

### 클라이언트에서 필요한 기능  
- **히스토리 관리**: `pushState`, `popstate` 이벤트 처리
- **동적 네비게이션**: 사용자 인터랙션에 따른 라우팅
- **브라우저 API**: `window.location`, `URLSearchParams` 등

## Q2: ServerRouter와 clientRouter가 어떻게 다른지 설명해줘.

### A2: ServerRouter가 실제로 서버 환경에 맞게 수정되었습니다! 주요 차이점들을 설명드리겠습니다:

### 1. `window` 객체 제거
```javascript
// 이전 (ClientRouter와 동일)
window.addEventListener("popstate", () => {
  this.#route = this.#findRoute();
  this.#observer.notify();
});

// 현재 ServerRouter - window 이벤트 리스너 완전 제거
constructor(baseUrl = "") {
  this.#routes = new Map();
  this.#route = null;
  this.#baseUrl = baseUrl.replace(/\/$/, "");
  // window 관련 코드 없음
}
```

### 2. pathname과 search를 인스턴스 속성으로 관리
```javascript
// 새로 추가된 속성들
pathname;
search;

// 서버에서는 직접 설정
start(pathname, search) {
  this.pathname = pathname;  // req.url에서 파싱한 값
  this.search = search;
  this.#route = this.#findRoute(pathname);
  this.#observer.notify();
}
```

### 3. query getter 변경
```javascript
// 이전 (window.location 사용)
get query() {
  return ClientRouter.parseQuery(window.location.search);
}

// 현재 ServerRouter (인스턴스 속성 사용)
get query() {
  return ServerRouter.parseQuery(this.search);
}
```

### 4. push 메서드 변경
```javascript
// 이전 (window.history 사용)
push(url) {
  window.history.pushState(null, "", fullUrl);
  this.#route = this.#findRoute(fullUrl);
  this.#observer.notify();
}

// 현재 ServerRouter (URL 파싱만)
push(url) {
  // URL 포맷을 위해 임시로 http://localhost 를 붙여줌
  const newURL = new URL(url, "http://localhost");
  this.pathname = newURL.pathname;
  this.search = newURL.search;
}
```

### 5. #findRoute 메서드 단순화
```javascript
// 이전 (window.location 의존)
#findRoute(url = window.location.pathname) {
  const { pathname } = new URL(url, window.location.origin);
  // ...
}

// 현재 ServerRouter (pathname 직접 사용)
#findRoute(pathname) {
  for (const [routePath, route] of this.#routes) {
    const match = pathname.match(route.regex);
    // ...
  }
}
```

## 핵심 차이점 비교

### ServerRouter
- `window` 객체 없이 동작
- `pathname`, `search`를 서버에서 직접 주입
- 히스토리 관리 없음 (단순 URL 파싱만)
- 정적 라우팅 (한 번 매칭하고 끝)

### ClientRouter
- `window` 객체 활용
- 브라우저 히스토리 관리
- 실시간 네비게이션
- 이벤트 기반 라우팅

## 결론

ServerRouter와 ClientRouter의 분리를 통해:

1. **서버**: `window` 객체 없이 `req.url`에서 받은 경로 정보로 정적 라우팅
2. **클라이언트**: 브라우저 API를 활용한 동적 네비게이션과 히스토리 관리
3. **환경 독립성**: 각 환경에 최적화된 라우터로 SSR과 클라이언트 렌더링 모두 지원

이제 서버와 클라이언트 환경의 차이를 제대로 반영한 별도의 라우터가 완성되었습니다!