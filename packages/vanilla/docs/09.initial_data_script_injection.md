# window.__INITIAL_DATA__ 스크립트 주입 구현 Q&A

## Q1: 지금 staged된 코드는 hydration을 위한 코드인 것 같은데, window.__INITIAL_DATA__ 스크립트를 주입하는 코드가 맞나요?

### A1: 네, 맞습니다! 현재 staged된 코드들은 **hydration을 위한 window.__INITIAL_DATA__ 스크립트 주입** 구현이 완성되었습니다.

## 변경된 주요 코드들

### 1. **HTML 템플릿 수정** (`index.html`)
```html
<body class="bg-gray-50">
  <div id="root"><!--app-html--></div>
  <script type="module" src="/src/main.js"></script>
  <!--app-data--> <!-- 새로 추가된 플레이스홀더 -->
</body>
```

### 2. **서버에서 스크립트 주입** (`server.js`)
```javascript
const html = template
  .replace(`<!--app-head-->`, rendered.head ?? "")
  .replace(`<!--app-html-->`, rendered.html ?? "")
  .replace(
    `<!-- app-data -->`,
    `<script>window.__INITIAL_DATA__ = ${JSON.stringify(rendered.__INITIAL_DATA__)};</script>`,
  );
```

**핵심 변화:**
- 기존: `APP_DATA` 플레이스홀더 → `<!-- app-data -->` 주석 형태
- 완전한 `<script>` 태그로 주입하여 바로 실행 가능

### 3. **데이터 처리 함수 개선** (`productService.js`)
```javascript
// setupProductsAndCategories - SSR용
export const setupProductsAndCategories = async (data) => {
  if (!data || productStore.getState().status === "done") {
    return; // data가 없거나 이미 설정된 경우 중복 방지
  }
  
  const [
    { products, pagination: { total } },
    categories,
  ] = data;
  
  productStore.dispatch({
    type: PRODUCT_ACTIONS.SETUP,
    payload: { products, categories, totalCount: total, loading: false, status: "done" },
  });
};
```

## 전체 Hydration 흐름

### 1. **서버 렌더링**
```javascript
// main-server.js에서
const data = await router.target.ssr({ query }); // [products, categories]
return {
  html: router.target({ data }),
  __INITIAL_DATA__: data
};
```

### 2. **HTML에 데이터 주입**
```html
<!-- 서버에서 생성된 HTML -->
<div id="root">상품 목록 HTML</div>
<script>window.__INITIAL_DATA__ = [products_data, categories_data];</script>
<script type="module" src="/src/main.js"></script>
```

### 3. **클라이언트 Hydration**
```javascript
// withServer에서
return page({ data: window.__INITIAL_DATA__ }); // 서버 데이터 전달

// HomePage에서  
setupProductsAndCategories(window.__INITIAL_DATA__); // store에 동일한 데이터 설정
```

## Q2: 코드 수정 전에서 발생할 수 있는 Hydration Mismatch 문제에 대해서 더 설명해줘.

### A2: Hydration Mismatch는 서버에서 생성된 HTML과 클라이언트가 생성한 HTML이 달라서 발생하는 SSR의 가장 큰 문제입니다.

## Hydration Mismatch란?

**Hydration**은 서버에서 생성된 정적 HTML을 클라이언트에서 동적으로 만드는 과정입니다. 이때 **서버 HTML과 클라이언트가 생성한 HTML이 달라서 발생하는 문제**가 Hydration Mismatch입니다.

## 우리 코드에서 발생할 수 있는 문제 상황

### 1. **수정 전 코드의 문제점**

#### 서버 렌더링 (main-server.js)
```javascript
export const render = async (pathname, query) => {
  router.start(pathname, query);
  
  // ❌ 서버에서는 데이터 없이 렌더링
  const data = undefined; // 또는 빈 데이터
  
  return {
    html: router.target({ pathname, query, data }), // 빈 데이터로 렌더링
    __INITIAL_DATA__: data,
  };
};
```

#### HomePage 서버 렌더링 결과
```html
<!-- 서버에서 생성된 HTML -->
<div class="product-list">
  <div class="loading">상품을 로딩중입니다...</div>
</div>
```

#### 클라이언트 Hydration
```javascript
// 클라이언트에서 실행
export const HomePage = withLifecycle(
  {
    onMount: () => {
      loadProductsAndCategories(); // API 호출
    },
  },
  () => {
    const productState = productStore.getState();
    
    if (productState.loading) {
      return `<div class="loading">상품을 로딩중입니다...</div>`; // 초기 상태
    }
    
    // 1-2초 후 API 응답이 오면
    return `
      <div class="product-list">
        <div class="product">아이폰 14</div>
        <div class="product">갤럭시 S23</div>
        <!-- 30개 상품 -->
      </div>
    `; // 완전히 다른 HTML!
  }
);
```

### 2. **발생하는 문제들**

#### A. **HTML 구조 불일치**
```javascript
// 서버 HTML
<div class="product-list">
  <div class="loading">상품을 로딩중입니다...</div>
</div>

// 클라이언트 HTML (API 응답 후)
<div class="product-list">
  <div class="product">아이폰 14</div>
  <div class="product">갤럭시 S23</div>
  <div class="product">맥북 프로</div>
  <!-- ... 27개 더 -->
</div>
```

#### B. **브라우저 경고/에러**
```
Warning: Text content does not match server-rendered HTML.
Warning: There was an error while hydrating. This error happened while hydrating, so the entire root will switch to client rendering.
```

#### C. **사용자 경험 문제**
```
1. 페이지 로드: "상품을 로딩중입니다..." (서버 HTML)
2. 1초 후: 갑자기 30개 상품이 나타남 (깜빡임 현상)
3. 레이아웃 시프트 발생
```

### 3. **타이밍 차이로 인한 문제**

```javascript
// 서버: 즉시 렌더링
const html = HomePage(); // loading 상태 HTML

// 클라이언트: API 호출 완료 후 렌더링  
setTimeout(() => {
  const html = HomePage(); // 상품 목록 HTML
}, 1500); // 네트워크 지연
```

**결과:** 같은 컴포넌트가 다른 시점에 다른 HTML을 생성

## 수정 후 해결 방법

### 1. **서버에서 데이터 미리 로드**
```javascript
// main-server.js
export const render = async (pathname, query) => {
  router.start(pathname, query);
  
  // ✅ 서버에서 데이터 미리 로드
  const data = await router.target.ssr({ pathname, query });
  // data = [products, categories]
  
  return {
    html: router.target({ pathname, query, data }), // 완성된 데이터로 렌더링
    __INITIAL_DATA__: data,
  };
};
```

### 2. **동일한 데이터로 렌더링**
```javascript
// 서버에서
setupProductsAndCategories([products, categories]); // 실제 데이터로 store 설정
const html = HomePage(); // 완성된 상품 목록 HTML

// 클라이언트에서  
setupProductsAndCategories(window.__INITIAL_DATA__); // 동일한 데이터로 store 설정
const html = HomePage(); // 동일한 상품 목록 HTML
```

### 3. **결과: 완벽한 일치**
```html
<!-- 서버 HTML -->
<div class="product-list">
  <div class="product">아이폰 14</div>
  <div class="product">갤럭시 S23</div>
  <!-- 30개 상품 -->
</div>

<!-- 클라이언트 HTML (Hydration 후) -->  
<div class="product-list">
  <div class="product">아이폰 14</div>
  <div class="product">갤럭시 S23</div>
  <!-- 정확히 동일한 30개 상품 -->
</div>
```

## 실제 발생 가능한 시나리오들

### 1. **날짜/시간 불일치**
```javascript
// 서버: 2024-01-15 10:00:00 (서버 시간)
// 클라이언트: 2024-01-15 19:00:00 (사용자 로컬 시간)
const currentTime = new Date().toLocaleString();
```

### 2. **랜덤 값 불일치**
```javascript
// 서버: Math.random() → 0.234
// 클라이언트: Math.random() → 0.876  
const randomId = Math.random();
```

### 3. **상태 기반 렌더링**
```javascript
// 서버: loading = true (초기 상태)
// 클라이언트: loading = false (API 완료 후)
if (loading) return "<div>로딩중...</div>";
return "<div>데이터 표시</div>";
```

## 해결 전략

### 1. **데이터 동기화**
- 서버에서 미리 로드한 데이터를 클라이언트에 전달
- 동일한 초기 상태로 시작

### 2. **조건부 렌더링 주의**
```javascript
// ❌ 위험한 패턴
if (typeof window !== 'undefined') {
  return "<div>클라이언트만</div>";
}

// ✅ 안전한 패턴  
if (data) {
  return "<div>데이터 있음</div>";
}
```

### 3. **생명주기 분리**
```javascript
// 클라이언트에서만 실행되는 로직을 onMount로 분리
// (우리는 withLifecycle의 onMount 사용)
```

## 핵심 이점

1. **Hydration Mismatch 방지**: 서버와 클라이언트가 동일한 데이터로 렌더링
2. **빠른 초기 로딩**: 서버에서 미리 로드된 데이터 사용
3. **부드러운 전환**: 로딩 상태 없이 바로 콘텐츠 표시
4. **SEO 최적화**: 완성된 HTML이 검색엔진에 노출

## 결론

**Hydration Mismatch는 SSR의 가장 큰 도전 과제**입니다. 서버와 클라이언트가 **동일한 입력으로 동일한 출력**을 생성하도록 보장하는 것이 핵심이며, 우리가 구현한 초기 데이터 주입 시스템이 이 문제를 해결하는 대표적인 방법입니다.