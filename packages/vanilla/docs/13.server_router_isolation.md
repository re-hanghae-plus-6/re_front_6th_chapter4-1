# 서버 환경 라우터 격리 구현 Q&A

## Q1: 지금 staged된 코드들은 서버 환경의 라우터를 격리한 것인가요?

### A1: 네, 맞습니다. 각 요청에 따라 라우터를 격리하여 동시 요청 처리 시 상태 혼선을 방지하는 것이 핵심입니다.

## Q2: 그러니까 젤 핵심적인 건 각 요청에 따라 라우터를 격리하기 위해서인 거죠?

### A2: 정확합니다! **각 요청에 따라 라우터를 격리**하는 것이 핵심입니다. Node.js는 싱글 스레드지만 동시 요청을 비동기로 처리하기 때문에, 글로벌 라우터를 쓰면 사용자가 완전히 다른 페이지를 받을 수 있습니다.

## 핵심 문제: 상태 공유의 위험성

### 기존 방식 (위험)
```javascript
// 글로벌 라우터 인스턴스 - 모든 요청이 공유
const router = new ServerRouter();

app.use('*', async (req, res) => {
  router.start(req.path, req.query); // 상태 변경
  const html = router.target(data);  // 다른 요청의 영향 받을 수 있음
});
```

**문제 상황:**
```javascript
// 요청 A와 요청 B가 동시에 처리될 때
요청 A: router.start("/product/123")  // router 상태 변경
요청 B: router.start("/user/456")     // router 상태 덮어씀 
요청 A: router.target() // 잘못된 핸들러 반환!
```

### 개선된 방식 (안전)
```javascript
// 각 요청마다 독립적인 라우터 인스턴스
export const render = async (pathname, query) => {
  const router = new ServerRouter(routerMatches); // 새 인스턴스
  router.start(pathname); // 이 요청만의 상태
  return {
    html: router.target({ pathname, query, data }), // 올바른 핸들러
    __INITIAL_DATA__: data,
  };
};
```

## Node.js 동시성과 Race Condition

### Node.js의 비동기 특성
```javascript
// 서버에서 동시에 처리되는 상황
// 0ms:   사용자 A → GET /product/123 (처리 시작)
// 10ms:  사용자 B → GET /admin/users  (처리 시작)  
// 20ms:  사용자 C → GET /login        (처리 시작)
// 30ms:  사용자 A의 응답 완료 (하지만 router 상태는 이미 /login...)

// 글로벌 router 공유 시
router.pathname = "/product/123"   // 사용자 A
router.pathname = "/admin/users"   // 사용자 B가 덮어씀
router.pathname = "/login"         // 사용자 C가 덮어씀

// 사용자 A가 받는 응답은?
// → 로그인 페이지! (완전히 잘못된 응답)
```

### Race Condition 실제 예시
```javascript
// 글로벌 라우터 사용 시 발생하는 버그
const router = new ServerRouter();

app.use('*', async (req, res) => {
  router.start(req.path, req.query); // 상태 변경
  
  // 비동기 작업 중에 다른 요청이 들어올 수 있음
  await fetchUserData();        // 100ms 소요
  await fetchProductData();     // 200ms 소요
  
  // 이 시점에서 router.target은?
  // → 마지막에 들어온 요청의 핸들러!
  const html = router.target(data); // 잘못된 페이지 렌더링
  res.send(html);
});
```

## 서버 vs 클라이언트 환경 차이

### 클라이언트 (브라우저)
```javascript
// 한 번에 하나의 페이지만 처리
// 사용자가 /product/123에 있으면 다른 경로로 동시에 가지 않음
const router = new ClientRouter(BASE_URL, routerMatches); 
// 글로벌 인스턴스 사용해도 문제없음
```

### 서버
```javascript
// 동시에 수백, 수천 개의 요청 처리
// 각 요청이 서로 다른 경로
// 상태 공유하면 절대 안 됨!

// ❌ 위험한 방식
const router = new ServerRouter(); // 모든 요청이 공유

// ✅ 안전한 방식  
function handleRequest() {
  const router = new ServerRouter(); // 요청별 독립 인스턴스
}
```

## 구현된 해결책 분석

### 1. ServerRouter 단순화
```javascript
// 불필요한 브라우저 전용 기능 제거
export class ServerRouter {
  #routes;
  #route;

  constructor(routerMatches) {
    this.#routes = new Map();
    this.#route = null;

    // 초기화 시 라우트 등록
    Object.entries(routerMatches).forEach(([pathname, page]) => {
      this.addRoute(pathname, page);
    });
  }

  // Observer, query 상태 관리 등 제거
  // 단순히 매칭과 핸들러 반환만 담당
  start(pathname) {
    this.#route = this.#findRoute(pathname);
  }
}
```

### 2. main-server.js에서 격리 적용
```javascript
export const render = async (pathname, query) => {
  // 💡 핵심: 매 요청마다 새로운 라우터 인스턴스 생성
  const router = new ServerRouter(routerMatches);
  
  router.start(pathname); // 독립적인 상태 설정
  const params = { pathname, query, params: router.params };
  
  // 이 요청만을 위한 라우터로 처리
  const data = (await router.target?.ssr?.(params)) ?? {};
  const metadata = await router.target?.metadata?.(params);

  return {
    head: `<title>${metadata?.title ?? ""}</title>`,
    html: router.target({ ...params, data }),
    __INITIAL_DATA__: data,
  };
};
```

### 3. router.js에서 환경별 분기
```javascript
export const routerMatches = {
  "/": HomePage,
  "/product/:id/": ProductDetailPage,
  ".*": NotFoundPage,
};

export const router = isServer
  ? // 서버: 더미 인스턴스 (실제 사용하지 않음)
    // 인터페이스 호환성만 위한 용도
    new ServerRouter({})
  : // 클라이언트: 실제 글로벌 라우터 인스턴스
    new ClientRouter(BASE_URL, routerMatches);
```

## 메모리 누수 방지 효과

### 글로벌 인스턴스의 문제
```javascript
// 서버가 계속 실행되면서 상태가 계속 쌓임
const globalRouter = new ServerRouter();

// 수천 개의 요청 처리 후...
globalRouter.#route = { /* 마지막 요청 정보만 남음 */ };
globalRouter.#observer.subscribers = [...]; // 누적된 구독자들

// 가비지 컬렉션이 어려움 - 메모리 누수 가능성
```

### 요청별 인스턴스의 장점
```javascript
function handleRequest() {
  const router = new ServerRouter(routerMatches); // 요청 시작
  // ... 요청 처리 ...
  return response;
} // 함수 종료 시 router 인스턴스 자동으로 가비지 컬렉션
```

## 실무에서의 일반적인 패턴

### Express.js 앱들
```javascript
// 대부분의 Express 앱은 이미 이렇게 구현
app.get('/users/:id', (req, res) => {
  // req, res는 이 요청만의 객체
  // 전역 상태를 공유하지 않음
  const userId = req.params.id; // 이 요청만의 파라미터
  res.json({ user: getUserById(userId) });
});
```

### Next.js
```javascript
// 페이지별로 독립적인 props
export async function getServerSideProps(context) {
  // context는 이 요청만의 객체
  return { 
    props: { 
      /* 이 요청만의 데이터 */ 
    } 
  };
}
```

### React Server Components
```javascript
// 각 컴포넌트 렌더링이 독립적
async function ProductPage({ params }) {
  // params는 이 렌더링만의 데이터
  const product = await getProduct(params.id);
  return <div>{product.name}</div>;
}
```

## 실제 버그 시나리오 예시

### 상황: 전자상거래 사이트
```javascript
// 15:32:10.100 - 사용자 A: 아이폰 14 상품 페이지 요청
// 15:32:10.150 - 사용자 B: 관리자 페이지 요청  
// 15:32:10.200 - 사용자 C: 로그인 페이지 요청
// 15:32:10.250 - 사용자 A: 응답 수신

// 글로벌 라우터 사용 시
router.start("/product/iphone14");  // 사용자 A
router.start("/admin");             // 사용자 B가 덮어씀  
router.start("/login");             // 사용자 C가 덮어씀

// 결과: 사용자 A가 아이폰 정보 대신 로그인 페이지를 받음!
```

### 보안 문제
```javascript
// 더 심각한 경우
// 15:32:10.100 - 일반 사용자: 상품 페이지 요청
// 15:32:10.120 - 관리자: 관리자 페이지 요청
// 15:32:10.140 - 일반 사용자가 관리자 페이지 내용을 받음!

// → 권한 없는 사용자가 관리자 정보에 접근
```

## 디버깅의 어려움

### 글로벌 라우터 사용 시
```javascript
// 버그 재현이 매우 어려움
// - 동시 요청 타이밍에 의존
// - 로컬 개발 환경에서는 발생하지 않을 수 있음  
// - 프로덕션에서만 간헐적으로 발생
// - 로그로 추적하기 어려움
```

### 격리된 라우터 사용 시
```javascript
// 예측 가능하고 디버깅 쉬움
// - 각 요청이 독립적
// - 재현 가능한 버그
// - 명확한 에러 스택 트레이스
```

## 성능 고려사항

### 인스턴스 생성 비용
```javascript
// 라우터 인스턴스 생성은 매우 가벼움
const router = new ServerRouter(routerMatches);
// - Map 객체 생성: ~0.01ms
// - 라우트 등록: ~0.1ms (라우트 수에 따라)
// - 총 비용: 무시할 수 있는 수준
```

### 메모리 사용량
```javascript
// 각 라우터 인스턴스 크기: ~1KB 미만
// 동시 요청 1000개라면: ~1MB 미만
// 현대 서버 메모리(8GB+) 대비 무시할 수 있는 수준
```

### GC (Garbage Collection) 효율
```javascript
// 요청 완료 후 자동으로 정리됨
// 메모리 누수 위험 없음
// 장시간 실행되는 서버에 최적화됨
```

## 결론

서버 환경 라우터 격리의 핵심은 **각 요청에 따라 라우터를 격리**하는 것입니다:

### 필수성
1. **동시성 안전**: Race condition 완전 방지
2. **상태 격리**: 요청 간 데이터 혼선 방지  
3. **보안 강화**: 권한 없는 데이터 접근 차단
4. **예측 가능성**: 각 요청이 독립적으로 처리

### 구현 원칙
- 글로벌 상태 공유 금지
- 요청별 독립 인스턴스 생성
- 메모리 효율적인 설계
- 가비지 컬렉션 최적화

**SSR에서는 반드시 적용해야 하는 필수 패턴**입니다. 이를 통해 각 사용자가 올바른 페이지를 받는 것을 보장할 수 있습니다.