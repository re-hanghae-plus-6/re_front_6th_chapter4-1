# pathname 정규화 구현 Q&A

## Q1: staged된 코드에서 pathname 정규화는 왜 필요한가요?

### A1: 악의적인 경로 탐색 공격을 방지하고, 일관된 라우팅을 보장하기 위해서입니다.

## 구현된 코드

### server.js 변경사항
```javascript
// 변경 전
const pathname = url.split("?")[0] || "/";

// 변경 후  
const pathname = path.normalize(`/${url.split("?")[0]}`);
```

## 정규화가 해결하는 문제들

### 1. **경로 탐색 공격 (Path Traversal Attack)**
```javascript
// 악의적인 요청 예시
GET /product/../../../etc/passwd
GET /user/./../../admin/secrets
GET ///admin///users///delete
```

**정규화 전:**
```javascript
pathname = "/product/../../../etc/passwd"  // 위험!
pathname = "/user/./../../admin/secrets"   // 위험!
```

**정규화 후:**
```javascript
pathname = "/etc/passwd"    // 상위 디렉토리 접근 차단
pathname = "/admin/secrets" // 현재 디렉토리 참조 제거
```

### 2. **중복 슬래시 제거**
```javascript
// 문제가 되는 URL들
"//product///123///"    → "/product/123/"
"/product//category//"  → "/product/category/"
"////"                  → "/"
```

### 3. **빈 경로 처리**
```javascript
// 빈 문자열이나 undefined 처리
""           → "/"
undefined    → "/"
"product"    → "/product"  // 앞에 슬래시 없는 경우
```

## 실제 공격 시나리오

### A. **파일 시스템 접근 시도**
```bash
# 공격자의 요청
GET /product/../../../package.json
GET /user/../../src/config/database.js
GET /.env

# 정규화 전 (위험)
pathname = "/product/../../../package.json"    # 실제 파일에 접근 가능
pathname = "/user/../../src/config/database.js" # 설정 파일 노출 위험

# 정규화 후 (안전)
pathname = "/package.json"           # 루트 레벨로 제한
pathname = "/src/config/database.js" # 상위 탐색 차단
```

### B. **라우터 우회 시도**
```javascript
// 공격자가 라우터를 혼란시키려는 시도
"/admin/./users"        → "/admin/users"
"/api/../admin/delete"  → "/admin/delete"
"/./././admin"          → "/admin"
```

## Node.js path.normalize() 동작 원리

### 1. **상대 경로 해석**
```javascript
path.normalize("/product/../login")     // → "/login"
path.normalize("/user/./profile")       // → "/user/profile"  
path.normalize("/admin/../../public")   // → "/public"
```

### 2. **중복 슬래시 정리**
```javascript
path.normalize("//product///123//")     // → "/product/123/"
path.normalize("/api////users")         // → "/api/users"
```

### 3. **끝 점(.) 처리**
```javascript
path.normalize("/product/.")            // → "/product"
path.normalize("/./product")            // → "/product"
path.normalize("/product/./")           // → "/product/"
```

## 보안 강화 효과

### Before: 취약한 상태
```javascript
// 공격 가능한 패턴들
const pathname = url.split("?")[0] || "/";

// 이런 요청들이 그대로 라우터에 전달
"/product/../admin"      // 관리자 페이지 접근 시도
"/user/../../config"     // 설정 파일 접근 시도
"//admin///delete///"    // 중복 슬래시로 라우터 혼란
```

### After: 안전한 상태
```javascript
// 모든 경로가 정규화되어 예측 가능
const pathname = path.normalize(`/${url.split("?")[0]}`);

// 정규화된 안전한 경로만 라우터에 전달
"/admin"         // 명확한 경로
"/config"        // 상위 탐색 차단됨
"/admin/delete"  // 정리된 경로
```
## 라우팅 일관성 보장

### A. **예측 가능한 라우트 매칭**
```javascript
// 정규화 전: 같은 페이지에 여러 경로로 접근 가능
"/product/123"
"/product/./123"  
"/product/../product/123"
"//product///123//"

// 정규화 후: 모든 요청이 동일한 경로로 정규화
"/product/123"  // 모든 요청이 이 형태로 변환됨
```

### B. **라우터 성능 향상**
```javascript
// 정규화된 경로는 라우터 매칭이 더 빠름
const routes = new Map([
  ["/product/:id", ProductHandler],
  ["/admin/users", AdminHandler],
  ["/", HomeHandler]
]);

// 깔끔한 경로로 빠른 매칭
routes.get("/product/123");  // 즉시 매칭
```

## Edge Cases 처리

### 1. **Windows 경로 스타일**
```javascript
// Windows 스타일 경로가 들어와도 안전하게 처리
path.normalize("/product\\..\\admin");  // → "/admin" (Unix 스타일로 변환)
```

### 2. **특수 문자 포함 경로**
```javascript
path.normalize("/product/../%2E%2E/admin");  // URL 디코딩 후 정규화 필요
// 주의: 이 경우 추가적인 URL 디코딩 처리가 필요할 수 있음
```

### 3. **매우 긴 경로**
```javascript
// 깊은 상위 탐색 시도도 안전하게 차단
const deepPath = "/product" + "/../".repeat(100) + "admin";
path.normalize(`/${deepPath}`);  // → "/admin"
```

## 추가 보안 고려사항

### 1. **URL 디코딩과 함께 사용**
```javascript
// 더 강화된 보안을 위해
const decodedUrl = decodeURIComponent(req.originalUrl);
const pathname = path.normalize(`/${decodedUrl.split("?")[0]}`);
```

### 2. **길이 제한**
```javascript
// 매우 긴 경로 공격 차단
if (pathname.length > 2048) {
  return res.status(414).end('URI Too Long');
}
```

### 3. **허용된 문자만 체크**
```javascript
// 특수 문자 필터링 (필요시)
if (!/^[a-zA-Z0-9\-_\/\.]+$/.test(pathname)) {
  return res.status(400).end('Invalid characters in path');
}
```

## 다른 프레임워크와의 비교

### Express.js 자체 기능
- Express는 기본적으로 일부 정규화를 수행
- 하지만 완전하지 않으므로 명시적 정규화 필요

### 웹 서버 레벨에서의 처리
- Nginx, Apache 등도 경로 정규화 수행
- 하지만 애플리케이션 레벨에서도 방어선 구축이 중요

## 결론

pathname 정규화는:

1. **필수 보안 조치**: 경로 탐색 공격 방지
2. **라우팅 안정성**: 일관된 경로 처리
3. **코드 예측성**: 깔끔하고 예측 가능한 라우트 매칭
4. **성능 향상**: 정규화된 경로로 빠른 라우터 매칭

**작은 코드 변경이지만 보안과 안정성에 큰 영향**을 미치는 중요한 개선사항입니다.