# 데이터 변환 책임 분리 리팩터링 Q&A

## Q1: 지금 staged된 코드는 왜 필요한거야? 동작에서는 차이 없지않나?

### A1: 동작상으로는 차이가 없지만, **데이터 변환 책임을 분리**해서 코드 구조와 유지보수성을 크게 개선한 리팩터링입니다.

## 변경사항 분석

### 변경 전 (기존 구조)
```javascript
// HomePage.js - SSR 함수
ssr: async ({ query }) => {
  return await Promise.all([getProducts(query), getCategories()]);
  // 반환: [products_response, categories_response] - 원본 API 응답
}

// productService.js - setupProductsAndCategories 
export const setupProductsAndCategories = async (data) => {
  const [
    { products, pagination: { total } },
    categories,
  ] = data;  // 원본 API 응답을 여기서 파싱
  
  productStore.dispatch({
    type: PRODUCT_ACTIONS.SETUP,
    payload: { products, categories, totalCount: total, loading: false, status: "done" },
  });
};
```

### 변경 후 (개선된 구조)
```javascript
// HomePage.js - ssrFetcher 함수
const ssrFetcher = async ({ query }) => {
  const [
    { products, pagination: { total } },
    categories,
  ] = await Promise.all([getProducts(query), getCategories()]);
  
  return {
    products,
    categories, 
    totalCount: total,
    loading: false,
    status: "done",
  }; // 이미 store에 들어갈 형태로 변환해서 반환
};

// productService.js - setupProductsAndCategories
export const setupProductsAndCategories = async (data) => {
  productStore.dispatch({
    type: PRODUCT_ACTIONS.SETUP,
    payload: data,  // 이미 변환된 데이터를 그대로 사용
  });
};
```

## Q2: 아 그러니까, productService에서는 멍청하게 주는 데이터만 받아서 쓰도록 하고, 데이터에 대한 명세와 호출에 필요한 부분을 ssrFetcher로 옮겨서 다른 부분에서도 재사용할 수 있도록 수정한거지?

### A2: 정확합니다! **"멍청한" productService**와 **"똑똑한" ssrFetcher**로 역할을 분리한 완벽한 리팩터링입니다!

## 핵심 개념

### **"멍청한" productService**
```javascript
// 변경 후: productService는 "멍청하게" 받은 데이터만 처리
export const setupProductsAndCategories = async (data) => {
  productStore.dispatch({
    type: PRODUCT_ACTIONS.SETUP,
    payload: data,  // 뭘 받든 그냥 store에 넣기만 함
  });
};
```

**특징:**
- API 구조를 **전혀 모름**
- 파싱 로직 **없음**
- 받은 데이터를 **그대로 store에 저장**만 함
- **단일 책임**: Store 업데이트만 담당

### **"똑똑한" ssrFetcher**  
```javascript
// 변경 후: ssrFetcher가 모든 "똑똑한" 일을 담당
const ssrFetcher = async ({ query }) => {
  const [
    { products, pagination: { total } },  // API 구조 알고 있음
    categories,
  ] = await Promise.all([getProducts(query), getCategories()]);

  return {
    products,     // 필요한 필드만 추출
    categories,
    totalCount: total,  // 이름도 store에 맞게 변경
    loading: false,     // store 초기 상태도 설정
    status: "done",
  };
};
```

**특징:**
- API 호출 방법 **알고 있음**
- API 응답 구조 **파악**
- store에 맞는 형태로 **변환**
- 초기 상태까지 **설정**
- **단일 책임**: 데이터 변환만 담당

## 개선된 점

### 1. **책임 분리 (Separation of Concerns)**
```javascript
// 변경 전: productService가 API 응답 구조를 알아야 함
setupProductsAndCategories([api_response1, api_response2]); // 원본 API 형태

// 변경 후: productService는 store 구조만 알면 됨  
setupProductsAndCategories(store_ready_data); // store에 맞는 형태
```

### 2. **데이터 흐름 명확화**
```javascript
// 변경 전: 애매한 데이터 흐름
SSR → [원본 API] → productService → 파싱 → store

// 변경 후: 명확한 데이터 흐름
SSR → 파싱 → [store 형태] → productService → store
```

### 3. **재사용성 향상**

#### Before (재사용 어려움)
```javascript
// 다른 페이지에서 사용하려면...
const OtherPage = () => {
  // ❌ API 구조를 또 알아야 함
  const [apiData1, apiData2] = await Promise.all([...]);
  setupProductsAndCategories([apiData1, apiData2]);
};
```

#### After (재사용 쉬움)
```javascript
// 다른 페이지에서 사용
const OtherPage = () => {
  // ✅ 표준화된 형태로 바로 사용
  const data = await ssrFetcher({ query });
  setupProductsAndCategories(data);
};

// 테스트에서도 쉽게 사용
const testData = {
  products: [...],
  categories: [...], 
  totalCount: 10,
  loading: false,
  status: "done"
};
setupProductsAndCategories(testData); // 간단!
```

### 4. **SSR 데이터 최적화**
```javascript
// window.__INITIAL_DATA__에 저장되는 데이터가 더 명확
window.__INITIAL_DATA__ = {
  products: [...],        // 명확한 필드명
  categories: [...],
  totalCount: 100,
  loading: false,
  status: "done"
} // store 구조와 일치
```

## 비유로 설명

### Before: 레스토랑 직원이 요리도 해야 함
```javascript
// setupProductsAndCategories = 서빙 직원
// 근데 재료(API 응답)를 받아서 요리(파싱)까지 해야 함
const 서빙직원 = (재료들) => {
  const 완성요리 = 재료들을_가공해서_요리만들기();
  손님에게_서빙(완성요리);
};
```

### After: 역할 분리
```javascript  
// ssrFetcher = 요리사
const 요리사 = () => {
  const 재료들 = 재료_구매();
  return 재료들을_가공해서_완성요리_만들기();
};

// setupProductsAndCategories = 서빙 직원  
const 서빙직원 = (완성요리) => {
  손님에게_서빙(완성요리); // 받은거 그대로 서빙만
};
```

## 소프트웨어 설계 원칙

이 변경은 **단일 책임 원칙(Single Responsibility Principle)**의 완벽한 예시입니다:

1. **ssrFetcher**: API 호출 + 데이터 변환 담당
2. **setupProductsAndCategories**: Store 업데이트만 담당

각자 **하나의 일**만 잘하도록 분리한 것입니다.

## 동작상 차이는 없지만...

맞습니다, **동작상으로는 차이가 없습니다**. 하지만 **코드 구조와 유지보수성**에서 큰 차이가 있습니다:

### Before (문제점)
- `setupProductsAndCategories`가 API 응답 구조에 의존
- 여러 곳에서 사용하기 어려움
- 데이터 변환 책임이 애매함
- 테스트하기 어려운 구조

### After (개선점)  
- `setupProductsAndCategories`는 순수하게 store 설정만 담당
- `ssrFetcher`가 명확하게 데이터 변환 담당
- 재사용 가능하고 테스트하기 쉬운 구조
- 각 함수가 명확한 단일 책임을 가짐

## 결론

이 변경은 **리팩터링**의 전형적인 예입니다:
- **기능적으로는 동일**하지만 
- **코드 품질과 구조**가 크게 개선됨
- **단일 책임 원칙** 적용
- **데이터 흐름 명확화**
- **재사용성과 유지보수성** 향상

작은 변경이지만 코드의 **가독성, 유지보수성, 재사용성**을 크게 향상시키는 의미 있는 개선입니다!