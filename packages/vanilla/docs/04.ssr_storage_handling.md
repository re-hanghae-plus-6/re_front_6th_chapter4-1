# SSR 환경에서의 Storage 처리 Q&A

## Q1: 지금 staged된 코드들은 cartStorage를 ssr환경에 대응하기 위한 코드들이야. 그렇다면 createMemoryStorage는 storage를 서버에 생성하는게 맞아?

### A1: 네, 맞습니다! `createMemoryStorage()`는 **서버 환경에서 storage를 메모리에 생성**하는 것이 맞습니다.

**코드 분석:**
```javascript
// cartStorage.js
export const cartStorage = createStorage(
  "shopping_cart",
  typeof window === "undefined" ? createMemoryStorage() : window.localStorage,
);
```

**환경별 동작:**
- **클라이언트** (`window !== undefined`): `window.localStorage` 사용
- **서버** (`window === undefined`): `createMemoryStorage()` 사용

**createMemoryStorage의 구현:**
```javascript
export const createMemoryStorage = () => {
  const storage = new Map();  // 메모리에 Map 객체 생성

  return {
    get: (key) => storage.get(key),
    set: (key, value) => storage.set(key, value),
    reset: () => storage.clear(),
  };
};
```

**왜 필요한가?**
1. **서버에는 localStorage가 없음**: Node.js 환경에는 브라우저의 localStorage API가 존재하지 않음
2. **SSR 호환성**: 서버에서 렌더링할 때도 동일한 storage 인터페이스 필요
3. **임시 저장소**: 서버에서는 각 요청마다 새로운 메모리 storage가 생성되어 SSR 과정에서만 사용

즉, 서버 환경에서 localStorage와 같은 인터페이스를 제공하지만 실제로는 메모리(Map)에 임시 저장하는 polyfill 역할을 합니다.

## Q2: 그러면 클라이언트에서 새로고침해도 storage의 값은 초기화되는건가? 서버에서 다시 페이지를 build해서 보내주니까?

### A2: 아니요! 클라이언트에서 새로고침해도 storage 값은 **초기화되지 않습니다**.

**이유:**

### SSR vs 클라이언트 렌더링의 차이
```javascript
// 서버에서 (SSR 시)
typeof window === "undefined" ? createMemoryStorage() : window.localStorage
// ↑ createMemoryStorage() 사용 (임시 메모리)

// 클라이언트에서 (브라우저)  
typeof window === "undefined" ? createMemoryStorage() : window.localStorage
// ↑ window.localStorage 사용 (영구 저장)
```

### 실제 동작 과정
1. **첫 방문**: 서버가 빈 메모리 storage로 HTML 생성 → 브라우저 전달
2. **클라이언트 hydration**: 브라우저에서 실제 localStorage로 전환
3. **사용자 상호작용**: localStorage에 데이터 저장
4. **새로고침**: 
   - 서버는 다시 빈 메모리 storage로 HTML 생성
   - 브라우저에서 다시 localStorage로 전환
   - **기존 localStorage 데이터는 그대로 유지**

## Q3: 아 그러니까 서버에서는 빈 메모리 storage로 html만 만들어서 클라이언트로 던지고, 클라이언트에서 localstorage랑 동기화해버린다. 그런데 localStorage는 새로고침해도 삭제되지 않는 저장소니까 보존된다는거지?

### A3: 정확합니다! 완벽한 이해입니다.

**정확한 흐름:**

1. **서버에서**: 빈 메모리 storage로 HTML 생성 → 클라이언트로 전송
2. **클라이언트에서**: localStorage와 동기화 (hydration)
3. **localStorage**: 브라우저의 영구 저장소라서 새로고침해도 유지됨

**예시:**
```javascript
// 1. 첫 방문 - 서버에서
createMemoryStorage() // 빈 Map {} 
→ HTML: <div>장바구니 없음</div>

// 2. 클라이언트 hydration
window.localStorage // 기존 데이터 있으면 복원
→ 실제 UI: <div>아이템 3개</div>

// 3. 새로고침
// 서버: 다시 빈 메모리 storage → HTML: <div>장바구니 없음</div>  
// 클라이언트: 다시 localStorage 복원 → UI: <div>아이템 3개</div>
```

**핵심:**
- **서버 메모리 storage** = SSR용 임시 저장소 (매번 리셋)
- **클라이언트 localStorage** = 영구 저장소 (새로고침 후에도 유지)

그래서 사용자가 장바구니에 담은 상품들이 새로고침해도 그대로 남아있는 것입니다!

## Q4: 근데 여기서 왜 map을 쓰는거야? 그냥 key value 형식이라 그런가?

### A4: 네, 맞습니다! `Map`을 사용하는 이유는 **localStorage와 동일한 key-value 인터페이스**를 제공하기 위해서입니다.

**localStorage API:**
```javascript
localStorage.getItem(key)
localStorage.setItem(key, value)  
localStorage.removeItem(key)
```

**Map API:**
```javascript
map.get(key)
map.set(key, value)
map.clear() // 모든 키 삭제
```

**왜 일반 객체 `{}` 대신 Map을 사용하는가?**

1. **더 나은 key 처리**:
```javascript
// 객체는 키가 항상 문자열로 변환됨
const obj = {};
obj[1] = 'value';
obj['1'] = 'another'; // 같은 키로 덮어씀

// Map은 다양한 타입의 키 지원
const map = new Map();
map.set(1, 'value');
map.set('1', 'another'); // 다른 키로 처리
```

2. **명확한 메서드**:
```javascript
// 객체
const obj = {};
obj[key] = value;
delete obj[key];

// Map (localStorage와 유사한 API)
const map = new Map();  
map.set(key, value);
map.delete(key);
```

3. **localStorage 호환성**:
```javascript
// createStorage가 기대하는 인터페이스
storage.getItem(key) // → map.get(key)
storage.setItem(key, value) // → map.set(key, value)
```

**결론:** Map을 사용하면 localStorage와 가장 유사한 동작을 구현할 수 있고, 객체보다 key-value 저장소로서 더 적합합니다.

## 전체 결론

SSR 환경에서 storage 처리는 다음과 같이 작동합니다:

1. **서버**: 임시 메모리 storage로 초기 HTML 렌더링
2. **클라이언트**: 실제 localStorage로 전환하여 영구 저장
3. **새로고침**: 서버는 다시 빈 상태로 렌더링하지만, 클라이언트에서 localStorage 데이터가 복원됨

이를 통해 SSR의 빠른 초기 로딩과 클라이언트의 상태 유지를 모두 달성할 수 있습니다.