# ServerRouter baseUrl 중복 적용 문제 해결 Q&A

## Q1: 지금 staged에 있는 코드는 왜 변경된거지? 경로 패턴은 애초에 왜 정규식으로 변환하는거야?

### A1: ServerRouter에서 baseUrl이 중복 적용되어 라우팅 매칭 실패가 발생했기 때문입니다. 정규식은 동적 라우팅과 정확한 매칭을 위해 사용됩니다.

## 변경된 이유

### 기존 코드 (문제 상황)
```javascript
const regex = new RegExp(`^${this.#baseUrl}${regexPath}$`);
```

### 변경된 코드 
```javascript
const regex = new RegExp(`^${regexPath}$`);
```

## 서버 환경에서의 URL 처리 차이

**서버에서는 이미 baseUrl이 제거된 경로를 받습니다:**

```javascript
// server.js에서
app.use("*all", async (req, res) => {
  const url = req.originalUrl.replace(base, ""); // baseUrl 이미 제거됨
  const pathname = url.split("?")[0] || "/";
  
  const rendered = await render(pathname, req.query); // 순수한 pathname 전달
});
```

### 문제가 되었던 상황
```javascript
// 전달되는 pathname: "/"
// baseUrl: "/front_6th_chapter4-1/vanilla/"
// 기존 정규식: ^/front_6th_chapter4-1/vanilla//$
// 매칭 시도: "/" → 실패! (baseUrl이 중복 적용됨)

// 수정된 정규식: ^/$  
// 매칭 시도: "/" → 성공!
```

## 경로 패턴을 정규식으로 변환하는 이유

### 1. **동적 라우팅 지원**
```javascript
// 경로 패턴: "/product/:id"
// 정규식 변환: "^/product/([^/]+)$"
// 매칭: "/product/123" → 성공, params: { id: "123" }
```

### 2. **정확한 매칭**
```javascript
// 정규식 없이 단순 문자열 매칭의 문제점
"/product".includes("/prod") // true (잘못된 매칭)

// 정규식으로 정확한 매칭
/^\/product$/.test("/prod") // false (정확한 매칭)
```

### 3. **패턴 변환 과정**
```javascript
// 원본 경로: "/product/:id"
const regexPath = path
  .replace(/:[^\/]+/g, "([^/]+)") // :id → ([^/]+)
  .replace(/\//g, "\\/");         // / → \/

// 최종 정규식: /^\/product\/([^/]+)$/
```

## Q2: ClientRouter.js의 구현에 대해서 자세히 알려줄래?

### A2: ClientRouter는 브라우저에서 SPA 라우팅을 담당하며, 동적 라우팅, baseUrl 지원, 옵저버 패턴을 통한 상태 관리를 제공합니다.

## 1. **기본 구조와 초기화**

```javascript
export class ClientRouter {
  #routes;        // Map<string, RouteConfig> - 등록된 라우트들
  #route;         // 현재 활성 라우트
  #observer;      // 옵저버 패턴으로 변경사항 알림
  #baseUrl;       // 기본 URL 경로

  constructor(baseUrl = "") {
    this.#routes = new Map();
    this.#route = null;
    this.#baseUrl = baseUrl.replace(/\/$/, ""); // 끝의 "/" 제거
    
    // 브라우저 뒤로가기/앞으로가기 감지
    window.addEventListener("popstate", () => {
      this.#route = this.#findRoute();
      this.#observer.notify();
    });
  }
}
```

**핵심:**
- **Private 필드** (`#`) 사용으로 내부 상태 보호
- **옵저버 패턴** 으로 라우트 변경 시 구독자들에게 알림
- **popstate 이벤트** 로 브라우저 네비게이션 감지

## 2. **라우트 등록 (`addRoute`)**

```javascript
addRoute(path, handler) {
  // 1. 동적 파라미터 추출
  const paramNames = [];
  const regexPath = path
    .replace(/:\w+/g, (match) => {
      paramNames.push(match.slice(1)); // ':id' -> 'id'
      return "([^/]+)";                // :id -> ([^/]+)
    })
    .replace(/\//g, "\\/");           // / -> \/
  
  // 2. baseUrl 포함한 정규식 생성
  const regex = new RegExp(`^${this.#baseUrl}${regexPath}$`);
  
  // 3. 라우트 정보 저장
  this.#routes.set(path, {
    regex,       // 매칭용 정규식
    paramNames,  // 파라미터 이름들 ['id', 'category']
    handler,     // 페이지 컴포넌트
  });
}
```

**변환 예시:**
```javascript
// 입력: "/product/:id/review/:reviewId"
// paramNames: ["id", "reviewId"]  
// regexPath: "\/product\/([^/]+)\/review\/([^/]+)"
// regex: /^\/base\/product\/([^/]+)\/review\/([^/]+)$/
```

## 3. **라우트 매칭 (`#findRoute`)**

```javascript
#findRoute(url = window.location.pathname) {
  const { pathname } = new URL(url, window.location.origin);
  
  for (const [routePath, route] of this.#routes) {
    const match = pathname.match(route.regex);
    
    if (match) {
      // 매치된 그룹들을 파라미터 객체로 변환
      const params = {};
      route.paramNames.forEach((name, index) => {
        params[name] = match[index + 1]; // match[0]은 전체 매치
      });
      
      return {
        ...route,
        params,      // { id: "123", reviewId: "456" }
        path: routePath, // 원본 패턴 "/product/:id/review/:reviewId"
      };
    }
  }
  return null; // 매치되는 라우트 없음
}
```

**매칭 예시:**
```javascript
// URL: "/base/product/123/review/456"
// 정규식: /^\/base\/product\/([^/]+)\/review\/([^/]+)$/
// match: ["/base/product/123/review/456", "123", "456"]
// params: { id: "123", reviewId: "456" }
```

## 4. **네비게이션 (`push`)**

```javascript
push(url) {
  try {
    // 1. baseUrl이 없으면 자동으로 추가
    let fullUrl = url.startsWith(this.#baseUrl) 
      ? url 
      : this.#baseUrl + (url.startsWith("/") ? url : "/" + url);
    
    const prevFullUrl = `${window.location.pathname}${window.location.search}`;
    
    // 2. 히스토리 업데이트 (중복 방지)
    if (prevFullUrl !== fullUrl) {
      window.history.pushState(null, "", fullUrl);
    }
    
    // 3. 새 라우트 찾기 및 알림
    this.#route = this.#findRoute(fullUrl);
    this.#observer.notify();
  } catch (error) {
    console.error("라우터 네비게이션 오류:", error);
  }
}
```

**URL 처리 예시:**
```javascript
// baseUrl: "/app"
router.push("/product/123")     // → "/app/product/123"
router.push("product/123")      // → "/app/product/123"  
router.push("/app/product/123") // → "/app/product/123" (그대로)
```

## 5. **쿼리 파라미터 처리**

```javascript
// 쿼리 읽기
get query() {
  return ClientRouter.parseQuery(window.location.search);
}

// 쿼리 업데이트
set query(newQuery) {
  const newUrl = ClientRouter.getUrl(newQuery, this.#baseUrl);
  this.push(newUrl);
}

// URL 생성 함수  
static getUrl = (newQuery, baseUrl = "") => {
  const currentQuery = ClientRouter.parseQuery();
  const updatedQuery = { ...currentQuery, ...newQuery };
  
  // 빈 값들 제거
  Object.keys(updatedQuery).forEach((key) => {
    if (updatedQuery[key] === null || updatedQuery[key] === undefined || updatedQuery[key] === "") {
      delete updatedQuery[key];
    }
  });
  
  const queryString = ClientRouter.stringifyQuery(updatedQuery);
  return `${baseUrl}${window.location.pathname.replace(baseUrl, "")}${queryString ? `?${queryString}` : ""}`;
};
```

## 사용 예시

```javascript
const router = new ClientRouter("/app");

// 라우트 등록
router.addRoute("/", HomePage);
router.addRoute("/product/:id", ProductPage);
router.addRoute("/category/:category/product/:id", DetailPage);

// 라우트 변경 감지
router.subscribe(() => {
  console.log("현재 라우트:", router.route);
  console.log("파라미터:", router.params);  // { id: "123" }
  console.log("쿼리:", router.query);        // { sort: "name" }
});

// 네비게이션
router.push("/product/123");           // 페이지 이동
router.query = { sort: "price" };      // 쿼리만 변경
```

## 핵심 특징

### 1. **동적 라우팅**
- `:id`, `:category` 같은 파라미터 지원
- 정규식으로 변환해서 정확한 매칭

### 2. **baseUrl 지원**  
- 서브디렉토리 배포 대응
- 자동으로 baseUrl 추가/제거

### 3. **옵저버 패턴**
- 라우트 변경 시 구독자들에게 알림
- UI 리렌더링 트리거

### 4. **브라우저 히스토리 관리**
- `pushState`로 히스토리 추가
- `popstate` 이벤트로 뒤로가기 감지

### 5. **쿼리 파라미터 관리**
- getter/setter로 쿼리 읽기/쓰기
- 빈 값 자동 제거

## 정규식 사용의 핵심 이점

1. **정확한 매칭**: 부분 문자열 매칭 방지
2. **파라미터 추출**: 캡처 그룹으로 동적 값 추출  
3. **유연한 패턴**: 복잡한 URL 구조 지원
4. **성능**: 한 번의 정규식 매치로 검증과 추출 동시 처리

## 결론

ClientRouter는 **React Router**나 **Vue Router**와 유사한 기능을 바닐라 JS로 구현한 것으로, SPA의 핵심인 클라이언트 사이드 라우팅을 담당합니다. 정규식을 활용한 동적 라우팅, baseUrl 지원, 옵저버 패턴을 통한 상태 관리 등 현대적인 SPA 라우터의 필수 기능들을 모두 포함하고 있습니다.